<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://hjson.org"

    >hjson (v2.4.1)</a>
</h1>
<h4>A user interface for JSON.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson">module hjson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.endOfLine">
            function <span class="apidocSignatureSpan">hjson.</span>endOfLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.parse">
            function <span class="apidocSignatureSpan">hjson.</span>parse
            <span class="apidocSignatureSpan">(source, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.setEndOfLine">
            function <span class="apidocSignatureSpan">hjson.</span>setEndOfLine
            <span class="apidocSignatureSpan">(eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.stringify">
            function <span class="apidocSignatureSpan">hjson.</span>stringify
            <span class="apidocSignatureSpan">(data, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>hjson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>hjson_common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>hjson_dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>rt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.comments">module hjson.comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.extract">
            function <span class="apidocSignatureSpan">hjson.comments.</span>extract
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.footer">
            function <span class="apidocSignatureSpan">hjson.comments.</span>footer
            <span class="apidocSignatureSpan">(value, setText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.header">
            function <span class="apidocSignatureSpan">hjson.comments.</span>header
            <span class="apidocSignatureSpan">(value, setText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.merge">
            function <span class="apidocSignatureSpan">hjson.comments.</span>merge
            <span class="apidocSignatureSpan">(comments, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.dsf">module hjson.dsf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.date">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.hex">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>hex
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.math">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>math
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson">module hjson.hjson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.endOfLine">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>endOfLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.parse">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>parse
            <span class="apidocSignatureSpan">(source, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.setEndOfLine">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>setEndOfLine
            <span class="apidocSignatureSpan">(eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.stringify">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>stringify
            <span class="apidocSignatureSpan">(data, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>rt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.hjson.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson_common">module hjson.hjson_common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.createComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>createComment
            <span class="apidocSignatureSpan">(value, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.forceComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>forceComment
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.getComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>getComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.removeComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>removeComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.tryParseNumber">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>tryParseNumber
            <span class="apidocSignatureSpan">(text, stopAtNext)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.hjson_common.</span>EOL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson_dsf">module hjson.hjson_dsf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_dsf.loadDsf">
            function <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>loadDsf
            <span class="apidocSignatureSpan">(col, type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>std</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.rt">module hjson.rt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.rt.parse">
            function <span class="apidocSignatureSpan">hjson.rt.</span>parse
            <span class="apidocSignatureSpan">(text, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.rt.stringify">
            function <span class="apidocSignatureSpan">hjson.rt.</span>stringify
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson" id="apidoc.module.hjson">module hjson</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.endOfLine" id="apidoc.element.hjson.endOfLine">
        function <span class="apidocSignatureSpan">hjson.</span>endOfLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endOfLine = function () { return common.EOL; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - &#x22;no-tabs&#x22;: like std but disallow tabs
    - &#x22;off&#x22;: show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as &#x27;\t&#x27; or &#x27;&#x26;nbsp;&#x27;), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.setEndOfLine())
  - *colors*: boolean, output ascii color codes

### Hjson.<span class="apidocCodeKeywordSpan">endOfLine</span>(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence (&#x27;\n&#x27; or &#x27;\r\n&#x27;). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }

This is a shortcut to roundtrip your comments when reading and updating a config file. It is the same as specifying the keepWsc
option for the parse and stringify functions.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.parse" id="apidoc.element.hjson.parse">
        function <span class="apidocSignatureSpan">hjson.</span>parse
        <span class="apidocSignatureSpan">(source, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (source, opt) {

  var common = require(&#x22;./hjson-common&#x22;);
  var dsf = require(&#x22;./hjson-dsf&#x22;);

  var text;
  var at;   // The index of the current character
  var ch;   // The current character
  var escapee = {
    &#x27;&#x22;&#x27;: &#x27;&#x22;&#x27;,
    &#x27;\\&#x27;: &#x27;\\&#x27;,
    &#x27;/&#x27;: &#x27;/&#x27;,
    b:  &#x27;\b&#x27;,
    f:  &#x27;\f&#x27;,
    n:  &#x27;\n&#x27;,
    r:  &#x27;\r&#x27;,
    t:  &#x27;\t&#x27;
  };

  var keepComments;
  var runDsf; // domain specific formats

  function resetAt() {
    at = 0;
    ch = &#x27; &#x27;;
  }

  function isPunctuatorChar(c) {
    return c === &#x27;{&#x27; || c === &#x27;}&#x27; || c === &#x27;[&#x27; || c === &#x27;]&#x27; || c === &#x27;,&#x27; || c === &#x27;:&#x27;;
  }

  // Call error when something is wrong.
  function error(m) {
    var i, col=0, line=1;
    for (i = at-1; i &#x3e; 0 &#x26;&#x26; text[i] !== &#x27;\n&#x27;; i--, col++) {}
    for (; i &#x3e; 0; i--) if (text[i] === &#x27;\n&#x27;) line++;
    throw new Error(m + &#x22; at line &#x22; + line + &#x22;,&#x22; + col + &#x22; &#x3e;&#x3e;&#x3e;&#x22; + text.substr(at-col, 20) + &#x22; ...&#x22;);
  }

  function next() {
    // get the next character.
    ch = text.charAt(at);
    at++;
    return ch;
  }

  function peek(offs) {
    // range check is not required
    return text.charAt(at + offs);
  }

  function string() {
    // Parse a string value.
    var string = &#x27;&#x27;;

    // When parsing for string values, we must look for &#x22; and \ characters.
    if (ch === &#x27;&#x22;&#x27;) {
      while (next()) {
        if (ch === &#x27;&#x22;&#x27;) {
          next();
          return string;
        }
        if (ch === &#x27;\\&#x27;) {
          next();
          if (ch === &#x27;u&#x27;) {
            var uffff = 0;
            for (var i = 0; i &#x3c; 4; i++) {
              next();
              var c = ch.charCodeAt(0), hex;
              if (ch &#x3e;= &#x27;0&#x27; &#x26;&#x26; ch &#x3c;= &#x27;9&#x27;) hex = c - 48;
              else if (ch &#x3e;= &#x27;a&#x27; &#x26;&#x26; ch &#x3c;= &#x27;f&#x27;) hex = c - 97 + 0xa;
              else if (ch &#x3e;= &#x27;A&#x27; &#x26;&#x26; ch &#x3c;= &#x27;F&#x27;) hex = c - 65 + 0xa;
              else error(&#x22;Bad \\u char &#x22; + ch);
              uffff = uffff * 16 + hex;
            }
            string += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === &#x27;string&#x27;) {
            string += escapee[ch];
          } else break;
        } else {
          string += ch;
        }
      }
    }
    error(&#x22;Bad string&#x22;);
  }

  function mlString() {
    // Parse a multiline string value.
    var string = &#x27;&#x27;, triple = 0;

    // we are at &#x27;&#x27;&#x27; +1 - get indent
    var indent = 0;
    for (;;) {
      var c=peek(-indent-5);
      if (!c || c === &#x27;\n&#x27;) break;
      indent++;
    }

    function skipIndent() {
      var skip = indent;
      while (ch &#x26;&#x26; ch &#x3c;= &#x27; &#x27; &#x26;&#x26; ch !== &#x27;\n&#x27; &#x26;&#x26; skip-- &#x3e; 0) next();
    }

    // skip white/to (newline)
    while (ch &#x26;&#x26; ch &#x3c;= &#x27; &#x27; &#x26;&#x26; ch !== &#x27;\n&#x27;) next();
    if (ch === &#x27;\n&#x27;) { next(); skipIndent(); }

    // When parsing multiline string values, we must look for &#x27; characters.
    for (;;) {
      if (!ch) {
        error(&#x22;Bad multiline string&#x22;);
      } else if (ch === &#x27;\&#x27;&#x27;) {
        triple++;
        next();
        if (triple === 3) {
          if (string.slice(-1) === &#x27;\n&#x27;) string=string.slice(0, -1); // remove last EOL
          return string;
        } else continue;
      } else {
        while (triple &#x3e; 0) {
          string += &#x27;\&#x27;&#x27;;
          triple--;
        }
      }
      if (ch === &#x27;\n&#x27;) {
        string += &#x27;\n&#x27;;
        next();
        skipIndent();
      } else {
        if (ch !== &#x27;\r&#x27;) string += ch;
        next();
      }
    }
  }

  function keyname() {
    // quotes for keys are optional in Hjson
    // unless they include {}[],: or whitespace.

    if (ch === &#x27;&#x22;&#x27;) return string();

    var name = &#x22;&#x22;, start = at, space = -1;
    for (;;) {
      if (ch === &#x27;:&#x27;) {
        if (!name) error(&#x22;Found &#x27;:&#x27; but no key name (for an empty key name use quotes)&#x22;);
        else if (space &#x3e;=0 &#x26;&#x26; space !== name.length) { at = start + space; error(&#x22;Found whitespace in your key name (use quotes
to include)&#x22;); }
        return name;
      } else if (ch &#x3c;= &#x27; &#x27;) {
        if (!ch) error(&#x22;Found EOF while looking for a key name (check your syntax)&#x22;);
        else if (space &#x3c; 0) space = name.length;
      } else if (isPunctuatorChar(ch)) {
        error(&#x22;Found &#x27;&#x22; + ch + &#x22;&#x27; where a key name was expected (check your syntax or us ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.setEndOfLine" id="apidoc.element.hjson.setEndOfLine">
        function <span class="apidocSignatureSpan">hjson.</span>setEndOfLine
        <span class="apidocSignatureSpan">(eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEndOfLine = function (eol) {
  if (eol === &#x27;\n&#x27; || eol === &#x27;\r\n&#x27;) common.EOL = eol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - &#x22;all&#x22;: use quotes around keys and string values
  - *multiline*: string, controls how multiline strings are displayed. (setting quotes implies &#x22;off&#x22;)
    - &#x22;std&#x22;: strings containing \n are shown in multiline format (default)
    - &#x22;no-tabs&#x22;: like std but disallow tabs
    - &#x22;off&#x22;: show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as &#x27;\t&#x27; or &#x27;&#x26;nbsp;&#x27;), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.<span class="apidocCodeKeywordSpan">setEndOfLine</span>())
  - *colors*: boolean, output ascii color codes

### Hjson.endOfLine(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence (&#x27;\n&#x27; or &#x27;\r\n&#x27;). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.stringify" id="apidoc.element.hjson.stringify">
        function <span class="apidocSignatureSpan">hjson.</span>stringify
        <span class="apidocSignatureSpan">(data, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (data, opt) {

  var common = require(&#x22;./hjson-common&#x22;);
  var dsf = require(&#x22;./hjson-dsf&#x22;);

  // options
  var eol = common.EOL;
  var indent = &#x27;  &#x27;;
  var keepComments = false;
  var bracesSameLine = false;
  var quoteKeys = false;
  var quoteStrings = false;
  var multiline = 1; // std=1, no-tabs=2, off=0
  var separator = &#x27;&#x27;; // comma separator
  var dsfDef = null;
  var token = {
    obj:  [ &#x27;{&#x27;, &#x27;}&#x27; ],
    arr:  [ &#x27;[&#x27;, &#x27;]&#x27; ],
    key:  [ &#x27;&#x27;,  &#x27;&#x27; ],
    qkey: [ &#x27;&#x22;&#x27;, &#x27;&#x22;&#x27; ],
    col:  [ &#x27;:&#x27; ],
    str:  [ &#x27;&#x27;, &#x27;&#x27; ],
    qstr: [ &#x27;&#x22;&#x27;, &#x27;&#x22;&#x27; ],
    mstr: [ &#x22;&#x27;&#x27;&#x27;&#x22;, &#x22;&#x27;&#x27;&#x27;&#x22; ],
    num:  [ &#x27;&#x27;, &#x27;&#x27; ],
    lit:  [ &#x27;&#x27;, &#x27;&#x27; ],
    dsf:  [ &#x27;&#x27;, &#x27;&#x27; ],
    esc:  [ &#x27;\\&#x27;, &#x27;&#x27; ],
    uni:  [ &#x27;\\u&#x27;, &#x27;&#x27; ],
    rem:  [ &#x27;&#x27;, &#x27;&#x27; ],
  };

  if (opt &#x26;&#x26; typeof opt === &#x27;object&#x27;) {
    opt.quotes = opt.quotes === &#x27;always&#x27; ? &#x27;strings&#x27; : opt.quotes; // legacy

    if (opt.eol === &#x27;\n&#x27; || opt.eol === &#x27;\r\n&#x27;) eol = opt.eol;
    keepComments = opt.keepWsc;
    bracesSameLine = opt.bracesSameLine;
    quoteKeys = opt.quotes === &#x27;all&#x27; || opt.quotes === &#x27;keys&#x27;;
    quoteStrings = opt.quotes === &#x27;all&#x27; || opt.quotes === &#x27;strings&#x27; || opt.separator === true;
    if (quoteStrings || opt.multiline == &#x27;off&#x27;) multiline = 0;
    else multiline = opt.multiline == &#x27;no-tabs&#x27; ? 2 : 1;
    separator = opt.separator === true ? &#x27;,&#x27; : &#x27;&#x27;;
    dsfDef = opt.dsf;

    // If the space parameter is a number, make an indent string containing that
    // many spaces. If it is a string, it will be used as the indent string.

    if (typeof opt.space === &#x27;number&#x27;) {
      indent = new Array(opt.space + 1).join(&#x27; &#x27;);
    } else if (typeof opt.space === &#x27;string&#x27;) {
      indent = opt.space;
    }

    if (opt.colors === true) {
      token = {
        obj:  [ &#x27;\x1b[37m{\x1b[0m&#x27;, &#x27;\x1b[37m}\x1b[0m&#x27; ],
        arr:  [ &#x27;\x1b[37m[\x1b[0m&#x27;, &#x27;\x1b[37m]\x1b[0m&#x27; ],
        key:  [ &#x27;\x1b[33m&#x27;,  &#x27;\x1b[0m&#x27; ],
        qkey: [ &#x27;\x1b[33m&#x22;&#x27;, &#x27;&#x22;\x1b[0m&#x27; ],
        col:  [ &#x27;\x1b[37m:\x1b[0m&#x27; ],
        str:  [ &#x27;\x1b[37;1m&#x27;, &#x27;\x1b[0m&#x27; ],
        qstr: [ &#x27;\x1b[37;1m&#x22;&#x27;, &#x27;&#x22;\x1b[0m&#x27; ],
        mstr: [ &#x22;\x1b[37;1m&#x27;&#x27;&#x27;&#x22;, &#x22;&#x27;&#x27;&#x27;\x1b[0m&#x22; ],
        num:  [ &#x27;\x1b[36;1m&#x27;, &#x27;\x1b[0m&#x27; ],
        lit:  [ &#x27;\x1b[36m&#x27;, &#x27;\x1b[0m&#x27; ],
        dsf:  [ &#x27;\x1b[37m&#x27;, &#x27;\x1b[0m&#x27; ],
        esc:  [ &#x27;\x1b[31m\\&#x27;, &#x27;\x1b[0m&#x27; ],
        uni:  [ &#x27;\x1b[31m\\u&#x27;, &#x27;\x1b[0m&#x27; ],
        rem:  [ &#x27;\x1b[35m&#x27;, &#x27;\x1b[0m&#x27; ],
      };
    }
  }

  //
  var runDsf; // domain specific formats

  var commonRange=&#x27;\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff&#x27;;
  // needsEscape tests if the string can be written without escapes
  var needsEscape = new RegExp(&#x27;[\\\\\\&#x22;\x00-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;g&#x27;);
  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\ and \&#x22;)
  var needsQuotes = new RegExp(&#x27;^\\s|^&#x22;|^\&#x27;\&#x27;\&#x27;|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;
g&#x27;);
  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \n, \r, \\, \&#x22;, \t unless
 multines is &#x27;std&#x27;)
  var needsEscapeML = new RegExp(&#x27;\&#x27;\&#x27;\&#x27;|^[\\s]+$|[\x00-&#x27;+(multiline === 2 ? &#x27;\x09&#x27; : &#x27;\x08&#x27;)+&#x27;\x0b\x0c\x0e-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;
g&#x27;);
  // starts with a keyword and optionally is followed by a comment
  var startsWithKeyword = new RegExp(&#x27;^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$&#x27;);
  var meta = {
    // table of character substitutions
    &#x27;\b&#x27;: &#x27;b&#x27;,
    &#x27;\t&#x27;: &#x27;t&#x27;,
    &#x27;\n&#x27;: &#x27;n&#x27;,
    &#x27;\f&#x27;: &#x27;f&#x27;,
    &#x27;\r&#x27;: &#x27;r&#x27;,
    &#x27;&#x22;&#x27; : &#x27;&#x22;&#x27;,
    &#x27;\\&#x27;: &#x27;\\&#x27;
  };
  var needsEscapeName = /[,\{\[\}\]\s:#&#x22;]|\/\/|\/\*|&#x27;&#x27;&#x27;/;
  var gap = &#x27;&#x27;;

  function wrap(tk, v) { return tk[0] + v + tk[1]; }

  function quoteReplace(string) {
    return string.replace(needsEscape, function (a) {
      var c = meta[a];
      if (typeof c === &#x27;string&#x27;) return wrap(token.esc, c);
      else return wrap(token.uni, (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4));
    });
  }

  function quote(string, gap, hasComment, isRootObject) {
    if (!string) return wrap(token.qstr, &#x27;&#x27;);

    needsQuotes.lastIndex = 0;
    startsWithKeyword ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.comments" id="apidoc.module.hjson.comments">module hjson.comments</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.comments.extract" id="apidoc.element.hjson.comments.extract">
        function <span class="apidocSignatureSpan">hjson.comments.</span>extract
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function (value) { return extractComments(value, true); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.footer" id="apidoc.element.hjson.comments.footer">
        function <span class="apidocSignatureSpan">hjson.comments.</span>footer
        <span class="apidocSignatureSpan">(value, setText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">footer = function (value, setText) { return rootComment(value, setText, 1); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.header" id="apidoc.element.hjson.comments.header">
        function <span class="apidocSignatureSpan">hjson.comments.</span>header
        <span class="apidocSignatureSpan">(value, setText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">header = function (value, setText) { return rootComment(value, setText, 0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.merge" id="apidoc.element.hjson.comments.merge">
        function <span class="apidocSignatureSpan">hjson.comments.</span>merge
        <span class="apidocSignatureSpan">(comments, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeComments(comments, value) {
  var dropped=[];
  merge(comments, value, dropped, []);

  // append dropped comments:
  if (dropped.length&#x3e;0) {
    var text=rootComment(value, null, 1);
    text+=&#x22;\n# Orphaned comments:\n&#x22;;
    dropped.forEach(function(c) {
      text+=(&#x22;# &#x22;+c.path.join(&#x27;/&#x27;)+&#x22;: &#x22;+mergeStr(c.b, c.a, c.e)).replace(&#x22;\n&#x22;, &#x22;\\n &#x22;)+&#x22;\n&#x22;;
    });
    rootComment(value, text, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.dsf" id="apidoc.module.hjson.dsf">module hjson.dsf</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.dsf.date" id="apidoc.element.hjson.dsf.date">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function date() {
  return {
    name: &#x22;date&#x22;,
    parse: function (value) {
      if (/^\d{4}-\d{2}-\d{2}$/.test(value) ||
        /^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:.\d+)(?:Z|[+-]\d{2}:\d{2})$/.test(value)) {
        var dt = Date.parse(value);
        if (!isNaN(dt)) return new Date(dt);
      }
    },
    stringify: function (value) {
      if (Object.prototype.toString.call(value) === &#x27;[object Date]&#x27;) {
        var dt = value.toISOString();
        if (dt.indexOf(&#x22;T00:00:00.000Z&#x22;, dt.length - 14) !== -1) return dt.substr(0, 10);
        else return dt;
      }
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (args.V || args[&#x22;-version&#x22;]) {
  console.log(&#x22;Hjson.js &#x22; + Hjson.version);
  return 0;
}

if (args[&#x22;+math&#x22;]) dsf.push(Hjson.dsf.math());
if (args[&#x22;+date&#x22;]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">date</span>({free:false}));
if (args[&#x22;+hex&#x22;]) dsf.push(Hjson.dsf.hex({out:false}));

var text;
if (argv.length) {
  text=fs.readFileSync(argv[0], &#x22;utf8&#x22;);
  convert(text);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.dsf.hex" id="apidoc.element.hjson.dsf.hex">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>hex
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(opt) {
  var out=opt &#x26;&#x26; opt.out;
  return {
    name: &#x22;hex&#x22;,
    parse: function (value) {
      if (/^0x[0-9A-Fa-f]+$/.test(value))
        return parseInt(value, 16);
    },
    stringify: function (value) {
      if (out &#x26;&#x26; Number.isInteger(value))
        return &#x22;0x&#x22;+value.toString(16);
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (args.V || args[&#x22;-version&#x22;]) {
  console.log(&#x22;Hjson.js &#x22; + Hjson.version);
  return 0;
}

if (args[&#x22;+math&#x22;]) dsf.push(Hjson.dsf.math());
if (args[&#x22;+date&#x22;]) dsf.push(Hjson.dsf.date({free:false}));
if (args[&#x22;+hex&#x22;]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">hex</span>({out:false}));

var text;
if (argv.length) {
  text=fs.readFileSync(argv[0], &#x22;utf8&#x22;);
  convert(text);
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.dsf.math" id="apidoc.element.hjson.dsf.math">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>math
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function math() {
  return {
    name: &#x22;math&#x22;,
    parse: function (value) {
      switch (value) {
        case &#x22;+inf&#x22;:
        case &#x22;inf&#x22;:
        case &#x22;+Inf&#x22;:
        case &#x22;Inf&#x22;: return Infinity;
        case &#x22;-inf&#x22;:
        case &#x22;-Inf&#x22;: return -Infinity;
        case &#x22;nan&#x22;:
        case &#x22;NaN&#x22;: return NaN;
      }
    },
    stringify: function (value) {
      if (typeof value !== &#x27;number&#x27;) return;
      if (1 / value === -Infinity) return &#x22;-0&#x22;; // 0 === -0
      if (value === Infinity) return &#x22;Inf&#x22;;
      if (value === -Infinity) return &#x22;-Inf&#x22;;
      if (isNaN(value)) return &#x22;NaN&#x22;;
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return 0;
}
else if (args.V || args[&#x22;-version&#x22;]) {
console.log(&#x22;Hjson.js &#x22; + Hjson.version);
return 0;
}

if (args[&#x22;+math&#x22;]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">math</span>());
if (args[&#x22;+date&#x22;]) dsf.push(Hjson.dsf.date({free:false}));
if (args[&#x22;+hex&#x22;]) dsf.push(Hjson.dsf.hex({out:false}));

var text;
if (argv.length) {
text=fs.readFileSync(argv[0], &#x22;utf8&#x22;);
convert(text);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson" id="apidoc.module.hjson.hjson">module hjson.hjson</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson.endOfLine" id="apidoc.element.hjson.hjson.endOfLine">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>endOfLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endOfLine = function () { return common.EOL; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - &#x22;no-tabs&#x22;: like std but disallow tabs
    - &#x22;off&#x22;: show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as &#x27;\t&#x27; or &#x27;&#x26;nbsp;&#x27;), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.setEndOfLine())
  - *colors*: boolean, output ascii color codes

### Hjson.<span class="apidocCodeKeywordSpan">endOfLine</span>(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence (&#x27;\n&#x27; or &#x27;\r\n&#x27;). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }

This is a shortcut to roundtrip your comments when reading and updating a config file. It is the same as specifying the keepWsc
option for the parse and stringify functions.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.parse" id="apidoc.element.hjson.hjson.parse">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>parse
        <span class="apidocSignatureSpan">(source, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (source, opt) {

  var common = require(&#x22;./hjson-common&#x22;);
  var dsf = require(&#x22;./hjson-dsf&#x22;);

  var text;
  var at;   // The index of the current character
  var ch;   // The current character
  var escapee = {
    &#x27;&#x22;&#x27;: &#x27;&#x22;&#x27;,
    &#x27;\\&#x27;: &#x27;\\&#x27;,
    &#x27;/&#x27;: &#x27;/&#x27;,
    b:  &#x27;\b&#x27;,
    f:  &#x27;\f&#x27;,
    n:  &#x27;\n&#x27;,
    r:  &#x27;\r&#x27;,
    t:  &#x27;\t&#x27;
  };

  var keepComments;
  var runDsf; // domain specific formats

  function resetAt() {
    at = 0;
    ch = &#x27; &#x27;;
  }

  function isPunctuatorChar(c) {
    return c === &#x27;{&#x27; || c === &#x27;}&#x27; || c === &#x27;[&#x27; || c === &#x27;]&#x27; || c === &#x27;,&#x27; || c === &#x27;:&#x27;;
  }

  // Call error when something is wrong.
  function error(m) {
    var i, col=0, line=1;
    for (i = at-1; i &#x3e; 0 &#x26;&#x26; text[i] !== &#x27;\n&#x27;; i--, col++) {}
    for (; i &#x3e; 0; i--) if (text[i] === &#x27;\n&#x27;) line++;
    throw new Error(m + &#x22; at line &#x22; + line + &#x22;,&#x22; + col + &#x22; &#x3e;&#x3e;&#x3e;&#x22; + text.substr(at-col, 20) + &#x22; ...&#x22;);
  }

  function next() {
    // get the next character.
    ch = text.charAt(at);
    at++;
    return ch;
  }

  function peek(offs) {
    // range check is not required
    return text.charAt(at + offs);
  }

  function string() {
    // Parse a string value.
    var string = &#x27;&#x27;;

    // When parsing for string values, we must look for &#x22; and \ characters.
    if (ch === &#x27;&#x22;&#x27;) {
      while (next()) {
        if (ch === &#x27;&#x22;&#x27;) {
          next();
          return string;
        }
        if (ch === &#x27;\\&#x27;) {
          next();
          if (ch === &#x27;u&#x27;) {
            var uffff = 0;
            for (var i = 0; i &#x3c; 4; i++) {
              next();
              var c = ch.charCodeAt(0), hex;
              if (ch &#x3e;= &#x27;0&#x27; &#x26;&#x26; ch &#x3c;= &#x27;9&#x27;) hex = c - 48;
              else if (ch &#x3e;= &#x27;a&#x27; &#x26;&#x26; ch &#x3c;= &#x27;f&#x27;) hex = c - 97 + 0xa;
              else if (ch &#x3e;= &#x27;A&#x27; &#x26;&#x26; ch &#x3c;= &#x27;F&#x27;) hex = c - 65 + 0xa;
              else error(&#x22;Bad \\u char &#x22; + ch);
              uffff = uffff * 16 + hex;
            }
            string += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === &#x27;string&#x27;) {
            string += escapee[ch];
          } else break;
        } else {
          string += ch;
        }
      }
    }
    error(&#x22;Bad string&#x22;);
  }

  function mlString() {
    // Parse a multiline string value.
    var string = &#x27;&#x27;, triple = 0;

    // we are at &#x27;&#x27;&#x27; +1 - get indent
    var indent = 0;
    for (;;) {
      var c=peek(-indent-5);
      if (!c || c === &#x27;\n&#x27;) break;
      indent++;
    }

    function skipIndent() {
      var skip = indent;
      while (ch &#x26;&#x26; ch &#x3c;= &#x27; &#x27; &#x26;&#x26; ch !== &#x27;\n&#x27; &#x26;&#x26; skip-- &#x3e; 0) next();
    }

    // skip white/to (newline)
    while (ch &#x26;&#x26; ch &#x3c;= &#x27; &#x27; &#x26;&#x26; ch !== &#x27;\n&#x27;) next();
    if (ch === &#x27;\n&#x27;) { next(); skipIndent(); }

    // When parsing multiline string values, we must look for &#x27; characters.
    for (;;) {
      if (!ch) {
        error(&#x22;Bad multiline string&#x22;);
      } else if (ch === &#x27;\&#x27;&#x27;) {
        triple++;
        next();
        if (triple === 3) {
          if (string.slice(-1) === &#x27;\n&#x27;) string=string.slice(0, -1); // remove last EOL
          return string;
        } else continue;
      } else {
        while (triple &#x3e; 0) {
          string += &#x27;\&#x27;&#x27;;
          triple--;
        }
      }
      if (ch === &#x27;\n&#x27;) {
        string += &#x27;\n&#x27;;
        next();
        skipIndent();
      } else {
        if (ch !== &#x27;\r&#x27;) string += ch;
        next();
      }
    }
  }

  function keyname() {
    // quotes for keys are optional in Hjson
    // unless they include {}[],: or whitespace.

    if (ch === &#x27;&#x22;&#x27;) return string();

    var name = &#x22;&#x22;, start = at, space = -1;
    for (;;) {
      if (ch === &#x27;:&#x27;) {
        if (!name) error(&#x22;Found &#x27;:&#x27; but no key name (for an empty key name use quotes)&#x22;);
        else if (space &#x3e;=0 &#x26;&#x26; space !== name.length) { at = start + space; error(&#x22;Found whitespace in your key name (use quotes
to include)&#x22;); }
        return name;
      } else if (ch &#x3c;= &#x27; &#x27;) {
        if (!ch) error(&#x22;Found EOF while looking for a key name (check your syntax)&#x22;);
        else if (space &#x3c; 0) space = name.length;
      } else if (isPunctuatorChar(ch)) {
        error(&#x22;Found &#x27;&#x22; + ch + &#x22;&#x27; where a key name was expected (check your syntax or us ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.setEndOfLine" id="apidoc.element.hjson.hjson.setEndOfLine">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>setEndOfLine
        <span class="apidocSignatureSpan">(eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEndOfLine = function (eol) {
  if (eol === &#x27;\n&#x27; || eol === &#x27;\r\n&#x27;) common.EOL = eol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - &#x22;all&#x22;: use quotes around keys and string values
  - *multiline*: string, controls how multiline strings are displayed. (setting quotes implies &#x22;off&#x22;)
    - &#x22;std&#x22;: strings containing \n are shown in multiline format (default)
    - &#x22;no-tabs&#x22;: like std but disallow tabs
    - &#x22;off&#x22;: show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as &#x27;\t&#x27; or &#x27;&#x26;nbsp;&#x27;), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.<span class="apidocCodeKeywordSpan">setEndOfLine</span>())
  - *colors*: boolean, output ascii color codes

### Hjson.endOfLine(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence (&#x27;\n&#x27; or &#x27;\r\n&#x27;). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.stringify" id="apidoc.element.hjson.hjson.stringify">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>stringify
        <span class="apidocSignatureSpan">(data, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (data, opt) {

  var common = require(&#x22;./hjson-common&#x22;);
  var dsf = require(&#x22;./hjson-dsf&#x22;);

  // options
  var eol = common.EOL;
  var indent = &#x27;  &#x27;;
  var keepComments = false;
  var bracesSameLine = false;
  var quoteKeys = false;
  var quoteStrings = false;
  var multiline = 1; // std=1, no-tabs=2, off=0
  var separator = &#x27;&#x27;; // comma separator
  var dsfDef = null;
  var token = {
    obj:  [ &#x27;{&#x27;, &#x27;}&#x27; ],
    arr:  [ &#x27;[&#x27;, &#x27;]&#x27; ],
    key:  [ &#x27;&#x27;,  &#x27;&#x27; ],
    qkey: [ &#x27;&#x22;&#x27;, &#x27;&#x22;&#x27; ],
    col:  [ &#x27;:&#x27; ],
    str:  [ &#x27;&#x27;, &#x27;&#x27; ],
    qstr: [ &#x27;&#x22;&#x27;, &#x27;&#x22;&#x27; ],
    mstr: [ &#x22;&#x27;&#x27;&#x27;&#x22;, &#x22;&#x27;&#x27;&#x27;&#x22; ],
    num:  [ &#x27;&#x27;, &#x27;&#x27; ],
    lit:  [ &#x27;&#x27;, &#x27;&#x27; ],
    dsf:  [ &#x27;&#x27;, &#x27;&#x27; ],
    esc:  [ &#x27;\\&#x27;, &#x27;&#x27; ],
    uni:  [ &#x27;\\u&#x27;, &#x27;&#x27; ],
    rem:  [ &#x27;&#x27;, &#x27;&#x27; ],
  };

  if (opt &#x26;&#x26; typeof opt === &#x27;object&#x27;) {
    opt.quotes = opt.quotes === &#x27;always&#x27; ? &#x27;strings&#x27; : opt.quotes; // legacy

    if (opt.eol === &#x27;\n&#x27; || opt.eol === &#x27;\r\n&#x27;) eol = opt.eol;
    keepComments = opt.keepWsc;
    bracesSameLine = opt.bracesSameLine;
    quoteKeys = opt.quotes === &#x27;all&#x27; || opt.quotes === &#x27;keys&#x27;;
    quoteStrings = opt.quotes === &#x27;all&#x27; || opt.quotes === &#x27;strings&#x27; || opt.separator === true;
    if (quoteStrings || opt.multiline == &#x27;off&#x27;) multiline = 0;
    else multiline = opt.multiline == &#x27;no-tabs&#x27; ? 2 : 1;
    separator = opt.separator === true ? &#x27;,&#x27; : &#x27;&#x27;;
    dsfDef = opt.dsf;

    // If the space parameter is a number, make an indent string containing that
    // many spaces. If it is a string, it will be used as the indent string.

    if (typeof opt.space === &#x27;number&#x27;) {
      indent = new Array(opt.space + 1).join(&#x27; &#x27;);
    } else if (typeof opt.space === &#x27;string&#x27;) {
      indent = opt.space;
    }

    if (opt.colors === true) {
      token = {
        obj:  [ &#x27;\x1b[37m{\x1b[0m&#x27;, &#x27;\x1b[37m}\x1b[0m&#x27; ],
        arr:  [ &#x27;\x1b[37m[\x1b[0m&#x27;, &#x27;\x1b[37m]\x1b[0m&#x27; ],
        key:  [ &#x27;\x1b[33m&#x27;,  &#x27;\x1b[0m&#x27; ],
        qkey: [ &#x27;\x1b[33m&#x22;&#x27;, &#x27;&#x22;\x1b[0m&#x27; ],
        col:  [ &#x27;\x1b[37m:\x1b[0m&#x27; ],
        str:  [ &#x27;\x1b[37;1m&#x27;, &#x27;\x1b[0m&#x27; ],
        qstr: [ &#x27;\x1b[37;1m&#x22;&#x27;, &#x27;&#x22;\x1b[0m&#x27; ],
        mstr: [ &#x22;\x1b[37;1m&#x27;&#x27;&#x27;&#x22;, &#x22;&#x27;&#x27;&#x27;\x1b[0m&#x22; ],
        num:  [ &#x27;\x1b[36;1m&#x27;, &#x27;\x1b[0m&#x27; ],
        lit:  [ &#x27;\x1b[36m&#x27;, &#x27;\x1b[0m&#x27; ],
        dsf:  [ &#x27;\x1b[37m&#x27;, &#x27;\x1b[0m&#x27; ],
        esc:  [ &#x27;\x1b[31m\\&#x27;, &#x27;\x1b[0m&#x27; ],
        uni:  [ &#x27;\x1b[31m\\u&#x27;, &#x27;\x1b[0m&#x27; ],
        rem:  [ &#x27;\x1b[35m&#x27;, &#x27;\x1b[0m&#x27; ],
      };
    }
  }

  //
  var runDsf; // domain specific formats

  var commonRange=&#x27;\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff&#x27;;
  // needsEscape tests if the string can be written without escapes
  var needsEscape = new RegExp(&#x27;[\\\\\\&#x22;\x00-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;g&#x27;);
  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\ and \&#x22;)
  var needsQuotes = new RegExp(&#x27;^\\s|^&#x22;|^\&#x27;\&#x27;\&#x27;|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;
g&#x27;);
  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \n, \r, \\, \&#x22;, \t unless
 multines is &#x27;std&#x27;)
  var needsEscapeML = new RegExp(&#x27;\&#x27;\&#x27;\&#x27;|^[\\s]+$|[\x00-&#x27;+(multiline === 2 ? &#x27;\x09&#x27; : &#x27;\x08&#x27;)+&#x27;\x0b\x0c\x0e-\x1f&#x27;+commonRange+&#x27;]&#x27;, &#x27;
g&#x27;);
  // starts with a keyword and optionally is followed by a comment
  var startsWithKeyword = new RegExp(&#x27;^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$&#x27;);
  var meta = {
    // table of character substitutions
    &#x27;\b&#x27;: &#x27;b&#x27;,
    &#x27;\t&#x27;: &#x27;t&#x27;,
    &#x27;\n&#x27;: &#x27;n&#x27;,
    &#x27;\f&#x27;: &#x27;f&#x27;,
    &#x27;\r&#x27;: &#x27;r&#x27;,
    &#x27;&#x22;&#x27; : &#x27;&#x22;&#x27;,
    &#x27;\\&#x27;: &#x27;\\&#x27;
  };
  var needsEscapeName = /[,\{\[\}\]\s:#&#x22;]|\/\/|\/\*|&#x27;&#x27;&#x27;/;
  var gap = &#x27;&#x27;;

  function wrap(tk, v) { return tk[0] + v + tk[1]; }

  function quoteReplace(string) {
    return string.replace(needsEscape, function (a) {
      var c = meta[a];
      if (typeof c === &#x27;string&#x27;) return wrap(token.esc, c);
      else return wrap(token.uni, (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4));
    });
  }

  function quote(string, gap, hasComment, isRootObject) {
    if (!string) return wrap(token.qstr, &#x27;&#x27;);

    needsQuotes.lastIndex = 0;
    startsWithKeyword ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson_common" id="apidoc.module.hjson.hjson_common">module hjson.hjson_common</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson_common.createComment" id="apidoc.element.hjson.hjson_common.createComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>createComment
        <span class="apidocSignatureSpan">(value, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createComment(value, comment) {
  if (Object.defineProperty) Object.defineProperty(value, &#x22;__COMMENTS__&#x22;, { enumerable: false, writable: true });
  return (value.__COMMENTS__ = comment||{});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!comments) return;
if (value===null || typeof value!==&#x27;object&#x27;) {
  dropAll(comments, dropped, path);
  return;
}

var i, length; // loop
var setComments=common.<span class="apidocCodeKeywordSpan">createComment</span>(value);

if (path.length===0 &#x26;&#x26; comments.r)
  setComments.r=[comments.r.b, comments.r.a];

if (Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;) {
  setComments.a=[];
  for (i=0, length=(comments.a||[]).length; i&#x3c;length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.forceComment" id="apidoc.element.hjson.hjson_common.forceComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>forceComment
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forceComment(text) {
  if (!text) return &#x22;&#x22;;
  var a = text.split(&#x27;\n&#x27;);
  var str, i, j, len;
  for (j = 0; j &#x3c; a.length; j++) {
    str = a[j];
    len = str.length;
    for (i = 0; i &#x3c; len; i++) {
      var c = str[i];
      if (c === &#x27;#&#x27;) break;
      else if (c === &#x27;/&#x27; &#x26;&#x26; (str[i+1] === &#x27;/&#x27; || str[i+1] === &#x27;*&#x27;)) {
        if (str[i+1] === &#x27;*&#x27;) j = a.length; // assume /**/ covers whole block, bail out
        break;
      }
      else if (c &#x3e; &#x27; &#x27;) {
        a[j] = &#x27;# &#x27; + str;
        break;
      }
    }
  }
  return a.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (comments.e) setComments.e=[comments.e.b, comments.e.a];
}
}

function rootComment(value, setText, header) {
var comment=common.createComment(value, common.getComment(value));
if (!comment.r) comment.r=[&#x22;&#x22;, &#x22;&#x22;];
if (setText || setText===&#x22;&#x22;) comment.r[header]=common.<span class="apidocCodeKeywordSpan">forceComment</span>(setText);
return comment.r[header]||&#x22;&#x22;;
}

module.exports={
extract: function(value) { return extractComments(value, true); },
merge: mergeComments,
header: function(value, setText) { return rootComment(value, setText, 0); },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.getComment" id="apidoc.element.hjson.hjson_common.getComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>getComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getComment(value) {
  return value.__COMMENTS__;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (x) (c=c||{}).x=x;
return c;
}

function extractComments(value, root) {

if (value===null || typeof value!==&#x27;object&#x27;) return;
var comments=common.<span class="apidocCodeKeywordSpan">getComment</span>(value);
if (comments) common.removeComment(value);

var i, length; // loop
var any, res;
if (Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;) {
  res={ a: [] };
  for (i=0, length=value.length; i&#x3c;length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.removeComment" id="apidoc.element.hjson.hjson_common.removeComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>removeComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeComment(value) {
  Object.defineProperty(value, &#x22;__COMMENTS__&#x22;, { value: undefined });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return c;
}

function extractComments(value, root) {

if (value===null || typeof value!==&#x27;object&#x27;) return;
var comments=common.getComment(value);
if (comments) common.<span class="apidocCodeKeywordSpan">removeComment</span>(value);

var i, length; // loop
var any, res;
if (Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;) {
  res={ a: [] };
  for (i=0, length=value.length; i&#x3c;length; i++) {
    if (saveComment(res.a, i, comments.a[i], extractComments(value[i])))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.tryParseNumber" id="apidoc.element.hjson.hjson_common.tryParseNumber">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>tryParseNumber
        <span class="apidocSignatureSpan">(text, stopAtNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryParseNumber(text, stopAtNext) {

  // try to parse a number

  var number, string = &#x27;&#x27;, leadingZeros = 0, testLeading = true;
  var at = 0;
  var ch;
  function next() {
    ch = text.charAt(at);
    at++;
    return ch;
  }

  next();
  if (ch === &#x27;-&#x27;) {
    string = &#x27;-&#x27;;
    next();
  }
  while (ch &#x3e;= &#x27;0&#x27; &#x26;&#x26; ch &#x3c;= &#x27;9&#x27;) {
    if (testLeading) {
      if (ch == &#x27;0&#x27;) leadingZeros++;
      else testLeading = false;
    }
    string += ch;
    next();
  }
  if (testLeading) leadingZeros--; // single 0 is allowed
  if (ch === &#x27;.&#x27;) {
    string += &#x27;.&#x27;;
    while (next() &#x26;&#x26; ch &#x3e;= &#x27;0&#x27; &#x26;&#x26; ch &#x3c;= &#x27;9&#x27;)
      string += ch;
  }
  if (ch === &#x27;e&#x27; || ch === &#x27;E&#x27;) {
    string += ch;
    next();
    if (ch === &#x27;-&#x27; || ch === &#x27;+&#x27;) {
      string += ch;
      next();
    }
    while (ch &#x3e;= &#x27;0&#x27; &#x26;&#x26; ch &#x3c;= &#x27;9&#x27;) {
      string += ch;
      next();
    }
  }

  // skip white/to (newline)
  while (ch &#x26;&#x26; ch &#x3c;= &#x27; &#x27;) next();

  if (stopAtNext) {
    // end scan if we find a punctuator character like ,}] or a comment
    if (ch === &#x27;,&#x27; || ch === &#x27;}&#x27; || ch === &#x27;]&#x27; ||
      ch === &#x27;#&#x27; || ch === &#x27;/&#x27; &#x26;&#x26; (text[at] === &#x27;/&#x27; || text[at] === &#x27;*&#x27;)) ch = 0;
  }

  number = +string;
  if (ch || leadingZeros || !isFinite(number)) return undefined;
  else return number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var chf = value[0];
switch (chf) {
  case &#x27;f&#x27;: if (value.trim() === &#x22;false&#x22;) return false; break;
  case &#x27;n&#x27;: if (value.trim() === &#x22;null&#x22;) return null; break;
  case &#x27;t&#x27;: if (value.trim() === &#x22;true&#x22;) return true; break;
  default:
    if (chf === &#x27;-&#x27; || chf &#x3e;= &#x27;0&#x27; &#x26;&#x26; chf &#x3c;= &#x27;9&#x27;) {
      var n = common.<span class="apidocCodeKeywordSpan">tryParseNumber</span>(value);
      if (n !== undefined) return n;
    }
}
if (isEol) {
  // remove any whitespace at the end (ignored in quoteless strings)
  value = value.trim();
  var dsfValue = runDsf(value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson_dsf" id="apidoc.module.hjson.hjson_dsf">module hjson.hjson_dsf</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson_dsf.loadDsf" id="apidoc.element.hjson.hjson_dsf.loadDsf">
        function <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>loadDsf
        <span class="apidocSignatureSpan">(col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDsf(col, type) {

  if (Object.prototype.toString.apply(col) !== &#x27;[object Array]&#x27;) {
    if (col) throw new Error(&#x22;dsf option must contain an array!&#x22;);
    else return nopDsf;
  } else if (col.length === 0) return nopDsf;

  var dsf = [];
  function isFunction(f) { return {}.toString.call(f) === &#x27;[object Function]&#x27;; }

  col.forEach(function(x) {
    if (!x.name || !isFunction(x.parse) || !isFunction(x.stringify))
      throw new Error(&#x22;extension does not match the DSF interface&#x22;);
    dsf.push(function() {
      try {
        if (type == &#x22;parse&#x22;) {
          return x.parse.apply(null, arguments);
        } else if (type == &#x22;stringify&#x22;) {
          var res=x.stringify.apply(null, arguments);
          // check result
          if (res !== undefined &#x26;&#x26; (typeof res !== &#x22;string&#x22; ||
            res.length === 0 ||
            res[0] === &#x27;&#x22;&#x27; ||
            [].some.call(res, function(c) { return isInvalidDsfChar(c); })))
            throw new Error(&#x22;value may not be empty, start with a quote or contain a punctuator character except colon: &#x22; + res);
          return res;
        } else throw new Error(&#x22;Invalid type&#x22;);
      } catch (e) {
        throw new Error(&#x22;DSF-&#x22;+x.name+&#x22; failed; &#x22;+e.message);
      }
    });
  });

  return runDsf.bind(null, dsf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (typeof source!==&#x22;string&#x22;) throw new Error(&#x22;source is not a string&#x22;);
  var dsfDef = null;
  if (opt &#x26;&#x26; typeof opt === &#x27;object&#x27;) {
    keepComments = opt.keepWsc;
    dsfDef = opt.dsf;
  }
  runDsf = dsf.<span class="apidocCodeKeywordSpan">loadDsf</span>(dsfDef, &#x22;parse&#x22;);
  text = source;
  resetAt();
  return rootValue();
};

},{&#x22;./hjson-common&#x22;:2,&#x22;./hjson-dsf&#x22;:3}],5:[function(require,module,exports){
/* Hjson http://hjson.org */
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.rt" id="apidoc.module.hjson.rt">module hjson.rt</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.rt.parse" id="apidoc.element.hjson.rt.parse">
        function <span class="apidocSignatureSpan">hjson.rt.</span>parse
        <span class="apidocSignatureSpan">(text, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (text, options) {
  (options=options||{}).keepWsc=true;
  return parse(text, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.rt.stringify" id="apidoc.element.hjson.rt.stringify">
        function <span class="apidocSignatureSpan">hjson.rt.</span>stringify
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (value, options) {
  (options=options||{}).keepWsc=true;
  return stringify(value, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require(&#x27;hjson&#x27;);

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
