<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://hjson.org">hjson (v2.4.1)</a>
</h1>
<h4>A user interface for JSON.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson">module hjson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.endOfLine">
            function <span class="apidocSignatureSpan">hjson.</span>endOfLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.parse">
            function <span class="apidocSignatureSpan">hjson.</span>parse
            <span class="apidocSignatureSpan">(source, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.setEndOfLine">
            function <span class="apidocSignatureSpan">hjson.</span>setEndOfLine
            <span class="apidocSignatureSpan">(eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.stringify">
            function <span class="apidocSignatureSpan">hjson.</span>stringify
            <span class="apidocSignatureSpan">(data, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>hjson</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>hjson_common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>hjson_dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.</span>rt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.comments">module hjson.comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.extract">
            function <span class="apidocSignatureSpan">hjson.comments.</span>extract
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.footer">
            function <span class="apidocSignatureSpan">hjson.comments.</span>footer
            <span class="apidocSignatureSpan">(value, setText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.header">
            function <span class="apidocSignatureSpan">hjson.comments.</span>header
            <span class="apidocSignatureSpan">(value, setText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.comments.merge">
            function <span class="apidocSignatureSpan">hjson.comments.</span>merge
            <span class="apidocSignatureSpan">(comments, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.dsf">module hjson.dsf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.date">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>date
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.hex">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>hex
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.dsf.math">
            function <span class="apidocSignatureSpan">hjson.dsf.</span>math
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson">module hjson.hjson</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.endOfLine">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>endOfLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.parse">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>parse
            <span class="apidocSignatureSpan">(source, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.setEndOfLine">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>setEndOfLine
            <span class="apidocSignatureSpan">(eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson.stringify">
            function <span class="apidocSignatureSpan">hjson.hjson.</span>stringify
            <span class="apidocSignatureSpan">(data, opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>comments</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>dsf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson.</span>rt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.hjson.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson_common">module hjson.hjson_common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.createComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>createComment
            <span class="apidocSignatureSpan">(value, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.forceComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>forceComment
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.getComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>getComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.removeComment">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>removeComment
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_common.tryParseNumber">
            function <span class="apidocSignatureSpan">hjson.hjson_common.</span>tryParseNumber
            <span class="apidocSignatureSpan">(text, stopAtNext)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">hjson.hjson_common.</span>EOL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.hjson_dsf">module hjson.hjson_dsf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.hjson_dsf.loadDsf">
            function <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>loadDsf
            <span class="apidocSignatureSpan">(col, type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>std</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hjson.rt">module hjson.rt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.rt.parse">
            function <span class="apidocSignatureSpan">hjson.rt.</span>parse
            <span class="apidocSignatureSpan">(text, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hjson.rt.stringify">
            function <span class="apidocSignatureSpan">hjson.rt.</span>stringify
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson" id="apidoc.module.hjson">module hjson</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.endOfLine" id="apidoc.element.hjson.endOfLine">
        function <span class="apidocSignatureSpan">hjson.</span>endOfLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endOfLine = function () { return common.EOL; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - "no-tabs": like std but disallow tabs
    - "off": show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as '\t' or '&amp;nbsp;'), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.setEndOfLine())
  - *colors*: boolean, output ascii color codes

### Hjson.<span class="apidocCodeKeywordSpan">endOfLine</span>(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence ('\n' or '\r\n'). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }

This is a shortcut to roundtrip your comments when reading and updating a config file. It is the same as specifying the keepWsc
option for the parse and stringify functions.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.parse" id="apidoc.element.hjson.parse">
        function <span class="apidocSignatureSpan">hjson.</span>parse
        <span class="apidocSignatureSpan">(source, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (source, opt) {

  var common = require("./hjson-common");
  var dsf = require("./hjson-dsf");

  var text;
  var at;   // The index of the current character
  var ch;   // The current character
  var escapee = {
    '"': '"',
    '\\': '\\',
    '/': '/',
    b:  '\b',
    f:  '\f',
    n:  '\n',
    r:  '\r',
    t:  '\t'
  };

  var keepComments;
  var runDsf; // domain specific formats

  function resetAt() {
    at = 0;
    ch = ' ';
  }

  function isPunctuatorChar(c) {
    return c === '{' || c === '}' || c === '[' || c === ']' || c === ',' || c === ':';
  }

  // Call error when something is wrong.
  function error(m) {
    var i, col=0, line=1;
    for (i = at-1; i &gt; 0 &amp;&amp; text[i] !== '\n'; i--, col++) {}
    for (; i &gt; 0; i--) if (text[i] === '\n') line++;
    throw new Error(m + " at line " + line + "," + col + " &gt;&gt;&gt;" + text.substr(at-col, 20) + " ...");
  }

  function next() {
    // get the next character.
    ch = text.charAt(at);
    at++;
    return ch;
  }

  function peek(offs) {
    // range check is not required
    return text.charAt(at + offs);
  }

  function string() {
    // Parse a string value.
    var string = '';

    // When parsing for string values, we must look for " and \ characters.
    if (ch === '"') {
      while (next()) {
        if (ch === '"') {
          next();
          return string;
        }
        if (ch === '\\') {
          next();
          if (ch === 'u') {
            var uffff = 0;
            for (var i = 0; i &lt; 4; i++) {
              next();
              var c = ch.charCodeAt(0), hex;
              if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') hex = c - 48;
              else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') hex = c - 97 + 0xa;
              else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') hex = c - 65 + 0xa;
              else error("Bad \\u char " + ch);
              uffff = uffff * 16 + hex;
            }
            string += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === 'string') {
            string += escapee[ch];
          } else break;
        } else {
          string += ch;
        }
      }
    }
    error("Bad string");
  }

  function mlString() {
    // Parse a multiline string value.
    var string = '', triple = 0;

    // we are at ''' +1 - get indent
    var indent = 0;
    for (;;) {
      var c=peek(-indent-5);
      if (!c || c === '\n') break;
      indent++;
    }

    function skipIndent() {
      var skip = indent;
      while (ch &amp;&amp; ch &lt;= ' ' &amp;&amp; ch !== '\n' &amp;&amp; skip-- &gt; 0) next();
    }

    // skip white/to (newline)
    while (ch &amp;&amp; ch &lt;= ' ' &amp;&amp; ch !== '\n') next();
    if (ch === '\n') { next(); skipIndent(); }

    // When parsing multiline string values, we must look for ' characters.
    for (;;) {
      if (!ch) {
        error("Bad multiline string");
      } else if (ch === '\'') {
        triple++;
        next();
        if (triple === 3) {
          if (string.slice(-1) === '\n') string=string.slice(0, -1); // remove last EOL
          return string;
        } else continue;
      } else {
        while (triple &gt; 0) {
          string += '\'';
          triple--;
        }
      }
      if (ch === '\n') {
        string += '\n';
        next();
        skipIndent();
      } else {
        if (ch !== '\r') string += ch;
        next();
      }
    }
  }

  function keyname() {
    // quotes for keys are optional in Hjson
    // unless they include {}[],: or whitespace.

    if (ch === '"') return string();

    var name = "", start = at, space = -1;
    for (;;) {
      if (ch === ':') {
        if (!name) error("Found ':' but no key name (for an empty key name use quotes)");
        else if (space &gt;=0 &amp;&amp; space !== name.length) { at = start + space; error("Found whitespace in your key name (use quotes
to include)"); }
        return name;
      } else if (ch &lt;= ' ') {
        if (!ch) error("Found EOF while looking for a key name (check your syntax)");
        else if (space &lt; 0) space = name.length;
      } else if (isPunctuatorChar(ch)) {
        error("Found '" + ch + "' where a key name was expected (check your syntax or us ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.setEndOfLine" id="apidoc.element.hjson.setEndOfLine">
        function <span class="apidocSignatureSpan">hjson.</span>setEndOfLine
        <span class="apidocSignatureSpan">(eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEndOfLine = function (eol) {
  if (eol === '\n' || eol === '\r\n') common.EOL = eol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - "all": use quotes around keys and string values
  - *multiline*: string, controls how multiline strings are displayed. (setting quotes implies "off")
    - "std": strings containing \n are shown in multiline format (default)
    - "no-tabs": like std but disallow tabs
    - "off": show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as '\t' or '&amp;nbsp;'), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.<span class="apidocCodeKeywordSpan">setEndOfLine</span>())
  - *colors*: boolean, output ascii color codes

### Hjson.endOfLine(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence ('\n' or '\r\n'). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.stringify" id="apidoc.element.hjson.stringify">
        function <span class="apidocSignatureSpan">hjson.</span>stringify
        <span class="apidocSignatureSpan">(data, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (data, opt) {

  var common = require("./hjson-common");
  var dsf = require("./hjson-dsf");

  // options
  var eol = common.EOL;
  var indent = '  ';
  var keepComments = false;
  var bracesSameLine = false;
  var quoteKeys = false;
  var quoteStrings = false;
  var multiline = 1; // std=1, no-tabs=2, off=0
  var separator = ''; // comma separator
  var dsfDef = null;
  var token = {
    obj:  [ '{', '}' ],
    arr:  [ '[', ']' ],
    key:  [ '',  '' ],
    qkey: [ '"', '"' ],
    col:  [ ':' ],
    str:  [ '', '' ],
    qstr: [ '"', '"' ],
    mstr: [ "'''", "'''" ],
    num:  [ '', '' ],
    lit:  [ '', '' ],
    dsf:  [ '', '' ],
    esc:  [ '\\', '' ],
    uni:  [ '\\u', '' ],
    rem:  [ '', '' ],
  };

  if (opt &amp;&amp; typeof opt === 'object') {
    opt.quotes = opt.quotes === 'always' ? 'strings' : opt.quotes; // legacy

    if (opt.eol === '\n' || opt.eol === '\r\n') eol = opt.eol;
    keepComments = opt.keepWsc;
    bracesSameLine = opt.bracesSameLine;
    quoteKeys = opt.quotes === 'all' || opt.quotes === 'keys';
    quoteStrings = opt.quotes === 'all' || opt.quotes === 'strings' || opt.separator === true;
    if (quoteStrings || opt.multiline == 'off') multiline = 0;
    else multiline = opt.multiline == 'no-tabs' ? 2 : 1;
    separator = opt.separator === true ? ',' : '';
    dsfDef = opt.dsf;

    // If the space parameter is a number, make an indent string containing that
    // many spaces. If it is a string, it will be used as the indent string.

    if (typeof opt.space === 'number') {
      indent = new Array(opt.space + 1).join(' ');
    } else if (typeof opt.space === 'string') {
      indent = opt.space;
    }

    if (opt.colors === true) {
      token = {
        obj:  [ '\x1b[37m{\x1b[0m', '\x1b[37m}\x1b[0m' ],
        arr:  [ '\x1b[37m[\x1b[0m', '\x1b[37m]\x1b[0m' ],
        key:  [ '\x1b[33m',  '\x1b[0m' ],
        qkey: [ '\x1b[33m"', '"\x1b[0m' ],
        col:  [ '\x1b[37m:\x1b[0m' ],
        str:  [ '\x1b[37;1m', '\x1b[0m' ],
        qstr: [ '\x1b[37;1m"', '"\x1b[0m' ],
        mstr: [ "\x1b[37;1m'''", "'''\x1b[0m" ],
        num:  [ '\x1b[36;1m', '\x1b[0m' ],
        lit:  [ '\x1b[36m', '\x1b[0m' ],
        dsf:  [ '\x1b[37m', '\x1b[0m' ],
        esc:  [ '\x1b[31m\\', '\x1b[0m' ],
        uni:  [ '\x1b[31m\\u', '\x1b[0m' ],
        rem:  [ '\x1b[35m', '\x1b[0m' ],
      };
    }
  }

  //
  var runDsf; // domain specific formats

  var commonRange='\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff';
  // needsEscape tests if the string can be written without escapes
  var needsEscape = new RegExp('[\\\\\\"\x00-\x1f'+commonRange+']', 'g');
  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\ and \")
  var needsQuotes = new RegExp('^\\s|^"|^\'\'\'|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f'+commonRange+']', '
g');
  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \n, \r, \\, \", \t unless
 multines is 'std')
  var needsEscapeML = new RegExp('\'\'\'|^[\\s]+$|[\x00-'+(multiline === 2 ? '\x09' : '\x08')+'\x0b\x0c\x0e-\x1f'+commonRange+']', '
g');
  // starts with a keyword and optionally is followed by a comment
  var startsWithKeyword = new RegExp('^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$');
  var meta = {
    // table of character substitutions
    '\b': 'b',
    '\t': 't',
    '\n': 'n',
    '\f': 'f',
    '\r': 'r',
    '"' : '"',
    '\\': '\\'
  };
  var needsEscapeName = /[,\{\[\}\]\s:#"]|\/\/|\/\*|'''/;
  var gap = '';

  function wrap(tk, v) { return tk[0] + v + tk[1]; }

  function quoteReplace(string) {
    return string.replace(needsEscape, function (a) {
      var c = meta[a];
      if (typeof c === 'string') return wrap(token.esc, c);
      else return wrap(token.uni, ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
    });
  }

  function quote(string, gap, hasComment, isRootObject) {
    if (!string) return wrap(token.qstr, '');

    needsQuotes.lastIndex = 0;
    startsWithKeyword ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.comments" id="apidoc.module.hjson.comments">module hjson.comments</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.comments.extract" id="apidoc.element.hjson.comments.extract">
        function <span class="apidocSignatureSpan">hjson.comments.</span>extract
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function (value) { return extractComments(value, true); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.footer" id="apidoc.element.hjson.comments.footer">
        function <span class="apidocSignatureSpan">hjson.comments.</span>footer
        <span class="apidocSignatureSpan">(value, setText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">footer = function (value, setText) { return rootComment(value, setText, 1); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.header" id="apidoc.element.hjson.comments.header">
        function <span class="apidocSignatureSpan">hjson.comments.</span>header
        <span class="apidocSignatureSpan">(value, setText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">header = function (value, setText) { return rootComment(value, setText, 0); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.comments.merge" id="apidoc.element.hjson.comments.merge">
        function <span class="apidocSignatureSpan">hjson.comments.</span>merge
        <span class="apidocSignatureSpan">(comments, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeComments(comments, value) {
  var dropped=[];
  merge(comments, value, dropped, []);

  // append dropped comments:
  if (dropped.length&gt;0) {
    var text=rootComment(value, null, 1);
    text+="\n# Orphaned comments:\n";
    dropped.forEach(function(c) {
      text+=("# "+c.path.join('/')+": "+mergeStr(c.b, c.a, c.e)).replace("\n", "\\n ")+"\n";
    });
    rootComment(value, text, 1);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.dsf" id="apidoc.module.hjson.dsf">module hjson.dsf</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.dsf.date" id="apidoc.element.hjson.dsf.date">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>date
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function date() {
  return {
    name: "date",
    parse: function (value) {
      if (/^\d{4}-\d{2}-\d{2}$/.test(value) ||
        /^\d{4}-\d{2}-\d{2}T\d{2}\:\d{2}\:\d{2}(?:.\d+)(?:Z|[+-]\d{2}:\d{2})$/.test(value)) {
        var dt = Date.parse(value);
        if (!isNaN(dt)) return new Date(dt);
      }
    },
    stringify: function (value) {
      if (Object.prototype.toString.call(value) === '[object Date]') {
        var dt = value.toISOString();
        if (dt.indexOf("T00:00:00.000Z", dt.length - 14) !== -1) return dt.substr(0, 10);
        else return dt;
      }
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (args.V || args["-version"]) {
  console.log("Hjson.js " + Hjson.version);
  return 0;
}

if (args["+math"]) dsf.push(Hjson.dsf.math());
if (args["+date"]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">date</span>({free:false}));
if (args["+hex"]) dsf.push(Hjson.dsf.hex({out:false}));

var text;
if (argv.length) {
  text=fs.readFileSync(argv[0], "utf8");
  convert(text);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.dsf.hex" id="apidoc.element.hjson.dsf.hex">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>hex
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(opt) {
  var out=opt &amp;&amp; opt.out;
  return {
    name: "hex",
    parse: function (value) {
      if (/^0x[0-9A-Fa-f]+$/.test(value))
        return parseInt(value, 16);
    },
    stringify: function (value) {
      if (out &amp;&amp; Number.isInteger(value))
        return "0x"+value.toString(16);
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (args.V || args["-version"]) {
  console.log("Hjson.js " + Hjson.version);
  return 0;
}

if (args["+math"]) dsf.push(Hjson.dsf.math());
if (args["+date"]) dsf.push(Hjson.dsf.date({free:false}));
if (args["+hex"]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">hex</span>({out:false}));

var text;
if (argv.length) {
  text=fs.readFileSync(argv[0], "utf8");
  convert(text);
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.dsf.math" id="apidoc.element.hjson.dsf.math">
        function <span class="apidocSignatureSpan">hjson.dsf.</span>math
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function math() {
  return {
    name: "math",
    parse: function (value) {
      switch (value) {
        case "+inf":
        case "inf":
        case "+Inf":
        case "Inf": return Infinity;
        case "-inf":
        case "-Inf": return -Infinity;
        case "nan":
        case "NaN": return NaN;
      }
    },
    stringify: function (value) {
      if (typeof value !== 'number') return;
      if (1 / value === -Infinity) return "-0"; // 0 === -0
      if (value === Infinity) return "Inf";
      if (value === -Infinity) return "-Inf";
      if (isNaN(value)) return "NaN";
    },
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return 0;
}
else if (args.V || args["-version"]) {
console.log("Hjson.js " + Hjson.version);
return 0;
}

if (args["+math"]) dsf.push(Hjson.dsf.<span class="apidocCodeKeywordSpan">math</span>());
if (args["+date"]) dsf.push(Hjson.dsf.date({free:false}));
if (args["+hex"]) dsf.push(Hjson.dsf.hex({out:false}));

var text;
if (argv.length) {
text=fs.readFileSync(argv[0], "utf8");
convert(text);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson" id="apidoc.module.hjson.hjson">module hjson.hjson</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson.endOfLine" id="apidoc.element.hjson.hjson.endOfLine">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>endOfLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endOfLine = function () { return common.EOL; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - "no-tabs": like std but disallow tabs
    - "off": show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as '\t' or '&amp;nbsp;'), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.setEndOfLine())
  - *colors*: boolean, output ascii color codes

### Hjson.<span class="apidocCodeKeywordSpan">endOfLine</span>(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence ('\n' or '\r\n'). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }

This is a shortcut to roundtrip your comments when reading and updating a config file. It is the same as specifying the keepWsc
option for the parse and stringify functions.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.parse" id="apidoc.element.hjson.hjson.parse">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>parse
        <span class="apidocSignatureSpan">(source, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (source, opt) {

  var common = require("./hjson-common");
  var dsf = require("./hjson-dsf");

  var text;
  var at;   // The index of the current character
  var ch;   // The current character
  var escapee = {
    '"': '"',
    '\\': '\\',
    '/': '/',
    b:  '\b',
    f:  '\f',
    n:  '\n',
    r:  '\r',
    t:  '\t'
  };

  var keepComments;
  var runDsf; // domain specific formats

  function resetAt() {
    at = 0;
    ch = ' ';
  }

  function isPunctuatorChar(c) {
    return c === '{' || c === '}' || c === '[' || c === ']' || c === ',' || c === ':';
  }

  // Call error when something is wrong.
  function error(m) {
    var i, col=0, line=1;
    for (i = at-1; i &gt; 0 &amp;&amp; text[i] !== '\n'; i--, col++) {}
    for (; i &gt; 0; i--) if (text[i] === '\n') line++;
    throw new Error(m + " at line " + line + "," + col + " &gt;&gt;&gt;" + text.substr(at-col, 20) + " ...");
  }

  function next() {
    // get the next character.
    ch = text.charAt(at);
    at++;
    return ch;
  }

  function peek(offs) {
    // range check is not required
    return text.charAt(at + offs);
  }

  function string() {
    // Parse a string value.
    var string = '';

    // When parsing for string values, we must look for " and \ characters.
    if (ch === '"') {
      while (next()) {
        if (ch === '"') {
          next();
          return string;
        }
        if (ch === '\\') {
          next();
          if (ch === 'u') {
            var uffff = 0;
            for (var i = 0; i &lt; 4; i++) {
              next();
              var c = ch.charCodeAt(0), hex;
              if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') hex = c - 48;
              else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') hex = c - 97 + 0xa;
              else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') hex = c - 65 + 0xa;
              else error("Bad \\u char " + ch);
              uffff = uffff * 16 + hex;
            }
            string += String.fromCharCode(uffff);
          } else if (typeof escapee[ch] === 'string') {
            string += escapee[ch];
          } else break;
        } else {
          string += ch;
        }
      }
    }
    error("Bad string");
  }

  function mlString() {
    // Parse a multiline string value.
    var string = '', triple = 0;

    // we are at ''' +1 - get indent
    var indent = 0;
    for (;;) {
      var c=peek(-indent-5);
      if (!c || c === '\n') break;
      indent++;
    }

    function skipIndent() {
      var skip = indent;
      while (ch &amp;&amp; ch &lt;= ' ' &amp;&amp; ch !== '\n' &amp;&amp; skip-- &gt; 0) next();
    }

    // skip white/to (newline)
    while (ch &amp;&amp; ch &lt;= ' ' &amp;&amp; ch !== '\n') next();
    if (ch === '\n') { next(); skipIndent(); }

    // When parsing multiline string values, we must look for ' characters.
    for (;;) {
      if (!ch) {
        error("Bad multiline string");
      } else if (ch === '\'') {
        triple++;
        next();
        if (triple === 3) {
          if (string.slice(-1) === '\n') string=string.slice(0, -1); // remove last EOL
          return string;
        } else continue;
      } else {
        while (triple &gt; 0) {
          string += '\'';
          triple--;
        }
      }
      if (ch === '\n') {
        string += '\n';
        next();
        skipIndent();
      } else {
        if (ch !== '\r') string += ch;
        next();
      }
    }
  }

  function keyname() {
    // quotes for keys are optional in Hjson
    // unless they include {}[],: or whitespace.

    if (ch === '"') return string();

    var name = "", start = at, space = -1;
    for (;;) {
      if (ch === ':') {
        if (!name) error("Found ':' but no key name (for an empty key name use quotes)");
        else if (space &gt;=0 &amp;&amp; space !== name.length) { at = start + space; error("Found whitespace in your key name (use quotes
to include)"); }
        return name;
      } else if (ch &lt;= ' ') {
        if (!ch) error("Found EOF while looking for a key name (check your syntax)");
        else if (space &lt; 0) space = name.length;
      } else if (isPunctuatorChar(ch)) {
        error("Found '" + ch + "' where a key name was expected (check your syntax or us ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.setEndOfLine" id="apidoc.element.hjson.hjson.setEndOfLine">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>setEndOfLine
        <span class="apidocSignatureSpan">(eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEndOfLine = function (eol) {
  if (eol === '\n' || eol === '\r\n') common.EOL = eol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    - "all": use quotes around keys and string values
  - *multiline*: string, controls how multiline strings are displayed. (setting quotes implies "off")
    - "std": strings containing \n are shown in multiline format (default)
    - "no-tabs": like std but disallow tabs
    - "off": show in JSON format
  - *separator*: boolean, output a comma separator between elements. Default false
  - *space*: specifies the indentation of nested structures. If it is a number, it will specify the number of spaces to indent at
 each level. If it is a string (such as '\t' or '&amp;nbsp;'), it contains the characters used to indent at each level.
  - *eol*: specifies the EOL sequence (default is set by Hjson.<span class="apidocCodeKeywordSpan">setEndOfLine</span>())
  - *colors*: boolean, output ascii color codes

### Hjson.endOfLine(), .setEndOfLine(eol)

Gets or sets the stringify EOL sequence ('\n' or '\r\n'). When running with node.js this defaults to os.EOL.

### Hjson.rt { parse, stringify }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson.stringify" id="apidoc.element.hjson.hjson.stringify">
        function <span class="apidocSignatureSpan">hjson.hjson.</span>stringify
        <span class="apidocSignatureSpan">(data, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (data, opt) {

  var common = require("./hjson-common");
  var dsf = require("./hjson-dsf");

  // options
  var eol = common.EOL;
  var indent = '  ';
  var keepComments = false;
  var bracesSameLine = false;
  var quoteKeys = false;
  var quoteStrings = false;
  var multiline = 1; // std=1, no-tabs=2, off=0
  var separator = ''; // comma separator
  var dsfDef = null;
  var token = {
    obj:  [ '{', '}' ],
    arr:  [ '[', ']' ],
    key:  [ '',  '' ],
    qkey: [ '"', '"' ],
    col:  [ ':' ],
    str:  [ '', '' ],
    qstr: [ '"', '"' ],
    mstr: [ "'''", "'''" ],
    num:  [ '', '' ],
    lit:  [ '', '' ],
    dsf:  [ '', '' ],
    esc:  [ '\\', '' ],
    uni:  [ '\\u', '' ],
    rem:  [ '', '' ],
  };

  if (opt &amp;&amp; typeof opt === 'object') {
    opt.quotes = opt.quotes === 'always' ? 'strings' : opt.quotes; // legacy

    if (opt.eol === '\n' || opt.eol === '\r\n') eol = opt.eol;
    keepComments = opt.keepWsc;
    bracesSameLine = opt.bracesSameLine;
    quoteKeys = opt.quotes === 'all' || opt.quotes === 'keys';
    quoteStrings = opt.quotes === 'all' || opt.quotes === 'strings' || opt.separator === true;
    if (quoteStrings || opt.multiline == 'off') multiline = 0;
    else multiline = opt.multiline == 'no-tabs' ? 2 : 1;
    separator = opt.separator === true ? ',' : '';
    dsfDef = opt.dsf;

    // If the space parameter is a number, make an indent string containing that
    // many spaces. If it is a string, it will be used as the indent string.

    if (typeof opt.space === 'number') {
      indent = new Array(opt.space + 1).join(' ');
    } else if (typeof opt.space === 'string') {
      indent = opt.space;
    }

    if (opt.colors === true) {
      token = {
        obj:  [ '\x1b[37m{\x1b[0m', '\x1b[37m}\x1b[0m' ],
        arr:  [ '\x1b[37m[\x1b[0m', '\x1b[37m]\x1b[0m' ],
        key:  [ '\x1b[33m',  '\x1b[0m' ],
        qkey: [ '\x1b[33m"', '"\x1b[0m' ],
        col:  [ '\x1b[37m:\x1b[0m' ],
        str:  [ '\x1b[37;1m', '\x1b[0m' ],
        qstr: [ '\x1b[37;1m"', '"\x1b[0m' ],
        mstr: [ "\x1b[37;1m'''", "'''\x1b[0m" ],
        num:  [ '\x1b[36;1m', '\x1b[0m' ],
        lit:  [ '\x1b[36m', '\x1b[0m' ],
        dsf:  [ '\x1b[37m', '\x1b[0m' ],
        esc:  [ '\x1b[31m\\', '\x1b[0m' ],
        uni:  [ '\x1b[31m\\u', '\x1b[0m' ],
        rem:  [ '\x1b[35m', '\x1b[0m' ],
      };
    }
  }

  //
  var runDsf; // domain specific formats

  var commonRange='\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff';
  // needsEscape tests if the string can be written without escapes
  var needsEscape = new RegExp('[\\\\\\"\x00-\x1f'+commonRange+']', 'g');
  // needsQuotes tests if the string can be written as a quoteless string (like needsEscape but without \\ and \")
  var needsQuotes = new RegExp('^\\s|^"|^\'\'\'|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f'+commonRange+']', '
g');
  // needsEscapeML tests if the string can be written as a multiline string (like needsEscape but without \n, \r, \\, \", \t unless
 multines is 'std')
  var needsEscapeML = new RegExp('\'\'\'|^[\\s]+$|[\x00-'+(multiline === 2 ? '\x09' : '\x08')+'\x0b\x0c\x0e-\x1f'+commonRange+']', '
g');
  // starts with a keyword and optionally is followed by a comment
  var startsWithKeyword = new RegExp('^(true|false|null)\\s*((,|\\]|\\}|#|//|/\\*).*)?$');
  var meta = {
    // table of character substitutions
    '\b': 'b',
    '\t': 't',
    '\n': 'n',
    '\f': 'f',
    '\r': 'r',
    '"' : '"',
    '\\': '\\'
  };
  var needsEscapeName = /[,\{\[\}\]\s:#"]|\/\/|\/\*|'''/;
  var gap = '';

  function wrap(tk, v) { return tk[0] + v + tk[1]; }

  function quoteReplace(string) {
    return string.replace(needsEscape, function (a) {
      var c = meta[a];
      if (typeof c === 'string') return wrap(token.esc, c);
      else return wrap(token.uni, ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
    });
  }

  function quote(string, gap, hasComment, isRootObject) {
    if (!string) return wrap(token.qstr, '');

    needsQuotes.lastIndex = 0;
    startsWithKeyword ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson_common" id="apidoc.module.hjson.hjson_common">module hjson.hjson_common</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson_common.createComment" id="apidoc.element.hjson.hjson_common.createComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>createComment
        <span class="apidocSignatureSpan">(value, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createComment(value, comment) {
  if (Object.defineProperty) Object.defineProperty(value, "__COMMENTS__", { enumerable: false, writable: true });
  return (value.__COMMENTS__ = comment||{});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!comments) return;
if (value===null || typeof value!=='object') {
  dropAll(comments, dropped, path);
  return;
}

var i, length; // loop
var setComments=common.<span class="apidocCodeKeywordSpan">createComment</span>(value);

if (path.length===0 &amp;&amp; comments.r)
  setComments.r=[comments.r.b, comments.r.a];

if (Object.prototype.toString.apply(value) === '[object Array]') {
  setComments.a=[];
  for (i=0, length=(comments.a||[]).length; i&lt;length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.forceComment" id="apidoc.element.hjson.hjson_common.forceComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>forceComment
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forceComment(text) {
  if (!text) return "";
  var a = text.split('\n');
  var str, i, j, len;
  for (j = 0; j &lt; a.length; j++) {
    str = a[j];
    len = str.length;
    for (i = 0; i &lt; len; i++) {
      var c = str[i];
      if (c === '#') break;
      else if (c === '/' &amp;&amp; (str[i+1] === '/' || str[i+1] === '*')) {
        if (str[i+1] === '*') j = a.length; // assume /**/ covers whole block, bail out
        break;
      }
      else if (c &gt; ' ') {
        a[j] = '# ' + str;
        break;
      }
    }
  }
  return a.join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (comments.e) setComments.e=[comments.e.b, comments.e.a];
}
}

function rootComment(value, setText, header) {
var comment=common.createComment(value, common.getComment(value));
if (!comment.r) comment.r=["", ""];
if (setText || setText==="") comment.r[header]=common.<span class="apidocCodeKeywordSpan">forceComment</span>(setText);
return comment.r[header]||"";
}

module.exports={
extract: function(value) { return extractComments(value, true); },
merge: mergeComments,
header: function(value, setText) { return rootComment(value, setText, 0); },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.getComment" id="apidoc.element.hjson.hjson_common.getComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>getComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getComment(value) {
  return value.__COMMENTS__;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (x) (c=c||{}).x=x;
return c;
}

function extractComments(value, root) {

if (value===null || typeof value!=='object') return;
var comments=common.<span class="apidocCodeKeywordSpan">getComment</span>(value);
if (comments) common.removeComment(value);

var i, length; // loop
var any, res;
if (Object.prototype.toString.apply(value) === '[object Array]') {
  res={ a: [] };
  for (i=0, length=value.length; i&lt;length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.removeComment" id="apidoc.element.hjson.hjson_common.removeComment">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>removeComment
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeComment(value) {
  Object.defineProperty(value, "__COMMENTS__", { value: undefined });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return c;
}

function extractComments(value, root) {

if (value===null || typeof value!=='object') return;
var comments=common.getComment(value);
if (comments) common.<span class="apidocCodeKeywordSpan">removeComment</span>(value);

var i, length; // loop
var any, res;
if (Object.prototype.toString.apply(value) === '[object Array]') {
  res={ a: [] };
  for (i=0, length=value.length; i&lt;length; i++) {
    if (saveComment(res.a, i, comments.a[i], extractComments(value[i])))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.hjson_common.tryParseNumber" id="apidoc.element.hjson.hjson_common.tryParseNumber">
        function <span class="apidocSignatureSpan">hjson.hjson_common.</span>tryParseNumber
        <span class="apidocSignatureSpan">(text, stopAtNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryParseNumber(text, stopAtNext) {

  // try to parse a number

  var number, string = '', leadingZeros = 0, testLeading = true;
  var at = 0;
  var ch;
  function next() {
    ch = text.charAt(at);
    at++;
    return ch;
  }

  next();
  if (ch === '-') {
    string = '-';
    next();
  }
  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
    if (testLeading) {
      if (ch == '0') leadingZeros++;
      else testLeading = false;
    }
    string += ch;
    next();
  }
  if (testLeading) leadingZeros--; // single 0 is allowed
  if (ch === '.') {
    string += '.';
    while (next() &amp;&amp; ch &gt;= '0' &amp;&amp; ch &lt;= '9')
      string += ch;
  }
  if (ch === 'e' || ch === 'E') {
    string += ch;
    next();
    if (ch === '-' || ch === '+') {
      string += ch;
      next();
    }
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
      string += ch;
      next();
    }
  }

  // skip white/to (newline)
  while (ch &amp;&amp; ch &lt;= ' ') next();

  if (stopAtNext) {
    // end scan if we find a punctuator character like ,}] or a comment
    if (ch === ',' || ch === '}' || ch === ']' ||
      ch === '#' || ch === '/' &amp;&amp; (text[at] === '/' || text[at] === '*')) ch = 0;
  }

  number = +string;
  if (ch || leadingZeros || !isFinite(number)) return undefined;
  else return number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var chf = value[0];
switch (chf) {
  case 'f': if (value.trim() === "false") return false; break;
  case 'n': if (value.trim() === "null") return null; break;
  case 't': if (value.trim() === "true") return true; break;
  default:
    if (chf === '-' || chf &gt;= '0' &amp;&amp; chf &lt;= '9') {
      var n = common.<span class="apidocCodeKeywordSpan">tryParseNumber</span>(value);
      if (n !== undefined) return n;
    }
}
if (isEol) {
  // remove any whitespace at the end (ignored in quoteless strings)
  value = value.trim();
  var dsfValue = runDsf(value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.hjson_dsf" id="apidoc.module.hjson.hjson_dsf">module hjson.hjson_dsf</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.hjson_dsf.loadDsf" id="apidoc.element.hjson.hjson_dsf.loadDsf">
        function <span class="apidocSignatureSpan">hjson.hjson_dsf.</span>loadDsf
        <span class="apidocSignatureSpan">(col, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDsf(col, type) {

  if (Object.prototype.toString.apply(col) !== '[object Array]') {
    if (col) throw new Error("dsf option must contain an array!");
    else return nopDsf;
  } else if (col.length === 0) return nopDsf;

  var dsf = [];
  function isFunction(f) { return {}.toString.call(f) === '[object Function]'; }

  col.forEach(function(x) {
    if (!x.name || !isFunction(x.parse) || !isFunction(x.stringify))
      throw new Error("extension does not match the DSF interface");
    dsf.push(function() {
      try {
        if (type == "parse") {
          return x.parse.apply(null, arguments);
        } else if (type == "stringify") {
          var res=x.stringify.apply(null, arguments);
          // check result
          if (res !== undefined &amp;&amp; (typeof res !== "string" ||
            res.length === 0 ||
            res[0] === '"' ||
            [].some.call(res, function(c) { return isInvalidDsfChar(c); })))
            throw new Error("value may not be empty, start with a quote or contain a punctuator character except colon: " + res);
          return res;
        } else throw new Error("Invalid type");
      } catch (e) {
        throw new Error("DSF-"+x.name+" failed; "+e.message);
      }
    });
  });

  return runDsf.bind(null, dsf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (typeof source!=="string") throw new Error("source is not a string");
  var dsfDef = null;
  if (opt &amp;&amp; typeof opt === 'object') {
    keepComments = opt.keepWsc;
    dsfDef = opt.dsf;
  }
  runDsf = dsf.<span class="apidocCodeKeywordSpan">loadDsf</span>(dsfDef, "parse");
  text = source;
  resetAt();
  return rootValue();
};

},{"./hjson-common":2,"./hjson-dsf":3}],5:[function(require,module,exports){
/* Hjson http://hjson.org */
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hjson.rt" id="apidoc.module.hjson.rt">module hjson.rt</a></h1>


    <h2>
        <a href="#apidoc.element.hjson.rt.parse" id="apidoc.element.hjson.rt.parse">
        function <span class="apidocSignatureSpan">hjson.rt.</span>parse
        <span class="apidocSignatureSpan">(text, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (text, options) {
  (options=options||{}).keepWsc=true;
  return parse(text, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.<span class="apidocCodeKeywordSpan">parse</span>(hjsonText);
var text2 = Hjson.stringify(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hjson.rt.stringify" id="apidoc.element.hjson.rt.stringify">
        function <span class="apidocSignatureSpan">hjson.rt.</span>stringify
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (value, options) {
  (options=options||{}).keepWsc=true;
  return stringify(value, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Usage

```
var Hjson = require('hjson');

var obj = Hjson.parse(hjsonText);
var text2 = Hjson.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
```

To keep comments intact see [API](#modify--keep-comments).

## From the Commandline

Install with `npm install hjson -g`.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>